\documentclass[12pt]{scrartcl}
\usepackage[sexy]{james}
\usepackage[noend]{algpseudocode}
\usepackage{answers}
\usepackage{array}
\usepackage{tikz}
\newenvironment{allintypewriter}{\ttfamily}{\par}
\usepackage{listings}
\usepackage{xcolor}
\usetikzlibrary{arrows.meta}
\usepackage{color}
\usepackage{mathtools}
\newcommand{\U}{\mathcal{U}}
\newcommand{\E}{\mathbb{E}}
\usetikzlibrary{arrows}
\Newassociation{hint}{hintitem}{all-hints}
\renewcommand{\solutionextension}{out}
\renewenvironment{hintitem}[1]{\item[\bfseries #1.]}{}
\renewcommand{\O}{\mathcal{O}}
\declaretheorem[style=thmbluebox,name={Chinese Remainder Theorem}]{CRT}
\renewcommand{\theCRT}{\Alph{CRT}}
\setlength\parindent{0pt}
\usepackage{sansmath}
\usepackage{pgfplots}

\usetikzlibrary{automata}
\usetikzlibrary{positioning}  %                 ...positioning nodes
\usetikzlibrary{arrows}       %                 ...customizing arrows
\newcommand{\eqdef}{=\vcentcolon}
\usepackage[top=3cm,left=3cm,right=3cm,bottom=3cm]{geometry}
\newcommand{\mref}[3][red]{\hypersetup{linkcolor=#1}\cref{#2}{#3}\hypersetup{linkcolor=blue}}%<<<changed

\tikzset{node distance=4.5cm, % Minimum distance between two nodes. Change if necessary.
         every state/.style={ % Sets the properties for each state
           semithick,
           fill=cyan!40},
         initial text={},     % No label on start arrow
         double distance=4pt, % Adjust appearance of accept states
         every edge/.style={  % Sets the properties for each transition
         draw,
           ->,>=stealth',     % Makes edges directed with bold arrowheads
           auto,
           semithick}}


% Start of document.
\newcommand{\sep}{\hspace*{.5em}}

\begin{document}
\title{Greedy Algorithms}
\author{James Zhang\thanks{Email: \mailto{jzhang72@terpmail.umd.edu}}}
\date{\today}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Backtracking}

A backtracking algorithm begins with an empty solution and extends 
the solution step by step, recursively going through all different ways 
how a solution can be constructed.

\subsection{Queens Problem}

We wish to place $n$ queens on an $n \times n$ such that no $2$ queens can attack 
each other.

\begin{note}
They key is to place queens row by row such that no queens can attack any of
the queens placed before.
\end{note}

\subsubsection{Pruning the Search}

At any time, if a partial solution cannot be extended to a complete solution, 
then just stop the search and save time. 

\subsection{Number of Paths in an n by n Grid}

Consider the problem of calculating the number of paths in an $n \times n$
grid from top left to bottom right and you have to reach every square exactly
once.

\subsubsection{Optimizations}

\begin{enumerate}
  \item Every path has a symmetric path, so either move right or down, do
backtracking, and multiply by $2$.
  \item If the path reaches the bottom right before visiting all other squares, terminate the search.
  \item If the path touches one of the squares in the first row, forcing us to either take a left or a right, 
terminate because we can't cross this veritcal line again.
  \item Generalize optimization 3. If we cannot ever move forward, but we can move left or right, 
  this splits the grid, so terminate the search.
\end{enumerate}

\subsection{Meet in the Middle}

Suppose we're given a list of $n$ numbers and a number $x$, and we want to choose some numbers 
from the list such that their sum is $x$. The basic algorithm is to generate all 
subsets and see if any of the sums are $x$.
\begin{note}
  Note that the time complexity is $O(2^n)$.
\end{note}

\subsubsection{Optimization}

Split the initial list into two lists $A$ and $B$ such that both lists contain 
about half the numbers. Generate all subsets of $A$ and store their sum in a 
list $S_a$, and do the same for $B$ and $S_B$. Now just check if you can 
choose an element from these new lists such that their sum equals.

\begin{note}
  Note that the time complexity is $O(2^{\frac{n}{2}}) = O(\sqrt{2^n}) \neq O(2^n)$
\end{note}

The algorithm is as follows.
\begin{itemize}
  \item Split the list into two even lists.
  \item Sort the two lists.
  \item Generate subsets from the two lists.
  \item Linearly check if a difference exists in the other array.
\end{itemize}

\section{Greedy Algorithms}

A greedy algorithm constructs a solution to the problem by always making the 
choice that looks best at the moment. It never back its choices,
but directly constructs the final solution.

\begin{note}
  It's difficult to prove that a greedy algorithms works. It's also not always
  optical solution $\to$ dynamic programming.
\end{note}

\subsection{Coin Problem}

Suppose we’re given $\{1,2,5, 10, 20, 50, 100, 200\}$ valued coins and we 
wish to form a sum money $n$ using the coins. Prove that a greedy algorithm works here.

\begin{proof}
We see that there should only be at most one of each of the following coins $\{1,5, 10, 50, 100\}$. 
If there were 2, it could be replaced by a coin twice as valuable. A 
similar observation can be made. there should be at most 2 $\{2, 20\}$ coins 
because if there were 3 20’s for example, then you could replace that with 50 + 10.
\end{proof}

\begin{note}
  Therefore it is not possible to optically construct a sum $x$ or any larger 
  sum by only using coins that are smaller than $x$, so the greedy solution works.
\end{note}

\begin{note}
  Greedy doesn’t always work, and counterexamples 
  can easily be provided such as if the coins are $\{1, 3, 4\}$ and x = 6 then greedy says 4 + 1 + 1 but optimal is 3 + 3.
\end{note}

\section{Minimizing Sums}

Consider the problem where we are given $n$ numbers $a_1, a_2, \cdots, a_n$ 
and our task is to find a value $x$ that minimizes the sum
\[|a_1-x|^c + |a_2-x|^c + \cdots + |a_n-x|^c\]
and we will focus on the cases $c=1, c=2$.

\subsection{Case c = 1}

In this case, we will choose the median of the numbers. 
If $n$ is even and there are two medians, then either median and all values between are optimal.
if x is smaller than the median, we can decrease the sum by increasing x. If x 
is larger than the median, we can decrease the sum by decreasing x.

\subsection{Case c = 2}
Now suppose we wish to minimize 
\[(a_1-x)^2 + (a_2-x)^2 + \cdots + (a_n-x)^2\]
The best choice here is the average of the numbers because expanding this sum of polynomials yields
\[nx^2 - 2x(a_1 + \cdots + a_n) + (a_1^2 + \cdots + a_n^2)\]
The last term is a constant, so we won’t worry about minimizing that; there’s nothing we can do. Now observe that the roots the above expression are
\[x = 0, \frac{2(a_1 + \cdots + a_n)}{n}\]
Since this is polynomial with a positive coefficient ie. opening upwards, the minimum is located at the average of the roots which is 
\[x = \frac{a_1 + \cdots + a_n}{n}\]
or simply the average of all of the numbers.

\section{Huffman Coding}

Huffman coding is a greedy algorithm that constructs an optimal code for compressing a given string.

\begin{enumerate}
\item The algorithm builds a binary tree based on the frequencies of the characters in the string.
\item Each character’s codeword can be read by following a path from the root to the corresponding node such that a move left corresponds to 0 and a move right corresponds to 1.
\item Finally at each step, nodes with minimum weights are combined, creating a new node with weight sum of its children. 
\item Repeat step 3 until all nodes have been combined.
\end{enumerate}


\end{document}
